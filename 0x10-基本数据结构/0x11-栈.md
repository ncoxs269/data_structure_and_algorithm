# 1. 介绍

栈是一种“后进先出”的线性数据结构。栈只有一端能够进出元素，我们一般称这一端为栈顶，另一端为栈底。添加或删除栈中元素时，我们只能将其插入到栈顶（进栈)，或者把栈顶元素从栈中取出（出栈)。

## 1.1 习题 41：Push, Pop, GetMin

实现一个栈，支持 Push (入栈）、Pop (出栈并输出栈顶）和 GetMin (查询钱中最小的值）三个橾作，要求时间复杂度均为 0(1)。

## 1.2 习题 42：Editor

你将要实现一个功能强大的整数序列编辑器。

在开始时，序列是空的。编辑器共有五种指令，如下：

1、`I x`，在光标处插入数值 $x$。
2、`D`，将光标前面的第一个元素删除，如果前面没有元素，则忽略此操作。
3、`L`，将光标向左移动，跳过一个元素，如果左边没有元素，则忽略此操作。
4、`R`，将光标向右移动，跳过一个元素，如果右边没有元素，则忽略此操作。
5、`Q k`，假设此刻光标之前的序列为 $a_1,a_2,\cdots,a_n$，输出 $max_{1\le i\le k}S_i$，其中 $S_i=a_1+a_2+\cdots+a_i$。

数据范围：

- $1\le Q \le 10^6$
- $|x|\le 10^3$
- $1\le k\le n$

# 题解

## 习题 41：Push,Pop, GetMin

空间换时间，每次 push 的时候，都额外记录当前的最小值。

```java
public static class MinStack implements IMinStack {

    private int[][] stack;
    private int top = -1;

    public MinStack() {
        stack = new int[16][2];
    }

    @Override
    public void push(int x) {
        if (top == stack.length - 1) {
            int[][] newStack = new int[stack.length * 2][2];
            System.arraycopy(stack, 0, newStack, 0, stack.length);
            stack = newStack;
        }
        stack[++top][0] = x;
        stack[top][1] = Math.min(x, top > 0 ? stack[top-1][1] : x);
    }

    @Override
    public void pop() {
        top--;
    }

    @Override
    public int top() {
        return stack[top][0];
    }

    @Override
    public int getMin() {
        return stack[top][1];
    }
}
```

## 习题 42：Editor

### 解法一

```java
public interface IEditor {

    void insert(int i);

    void delete();

    void moveLeft();

    void moveRight();

    int query(int k);
}

public static class Editor implements IEditor {

    private final List<int[]> seq;
    private int cursor;

    public Editor() {
        seq = new ArrayList<>();
    }

    public void insert(int i) {
        if (cursor > 0) {
            int[] prev = seq.get(cursor - 1);
            seq.add(cursor, new int[]{i, prev[1] + i, Math.max(prev[1] + i, prev[2])});
        } else {
            seq.add(cursor, new int[]{i, i, i});
        }
        cursor++;
    }

    public void delete() {
        if (cursor > 0) {
            seq.remove(--cursor);
        }
    }

    public void moveLeft() {
        if (cursor > 0) {
            cursor--;
        }
    }

    public void moveRight() {
        // 每次往右移就更新 maxQuery，防止之前删除的脏数据
        if (cursor < seq.size() && ++cursor > 1) {
            int[] prev = seq.get(cursor - 2), cur = seq.get(cursor - 1);
            cur[1] = prev[1] + cur[0];
            cur[2] = Math.max(cur[1], prev[2]);
        }
    }

    public int query(int k) {
        return seq.get(k - 1)[2];
    }
}

public void execute(IEditor editor) {
    try {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(in.readLine());
        for (int i = 0; i < n; i++) {
            String s = in.readLine();
            char operator = s.charAt(0);
            switch (operator) {
                case 'I':
                    editor.insert(Integer.parseInt(s.substring(2)));
                    break;

                case 'D':
                    editor.delete();
                    break;

                case 'L':
                    editor.moveLeft();
                    break;

                case 'R':
                    editor.moveRight();
                    break;

                case 'Q':
                    System.out.println(editor.query(Integer.parseInt(s.substring(2))));
                    break;
            }
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}

public void editorExecute() {
    execute(new Editor());
}
```

### 解法二

```java
/**
 * 双栈法，参见 https://www.acwing.com/solution/content/1275/
 */
public static class StackEditor implements IEditor {

    private static class Seq {

        private final List<Integer> list = new ArrayList<>();

        public int get(int i) {
            return list.get(i);
        }

        public void set(int i, int num) {
            if (i >= list.size()) {
                list.add(num);
            } else {
                list.set(i, num);
            }
        }
    }

    // 保存光标前数字的栈，和光标后数字的栈
    private final Deque<Integer> prevStack, nextStack;
    private final Seq prefix, max;

    public StackEditor() {
        prevStack = new ArrayDeque<>();
        nextStack = new ArrayDeque<>();
        prefix = new Seq();
        max = new Seq();
    }

    public void insert(int i) {
        prevStack.push(i);
        if (prevStack.size() == 1) {
            prefix.set(0, i);
            max.set(0, i);
        } else {
            int prev = prevStack.size() - 2, cur = prevStack.size() - 1;
            int sum = prefix.get(prev) + i;
            prefix.set(cur, sum);
            max.set(cur, Math.max(sum, max.get(prev)));
        }
    }

    public void delete() {
        if (!prevStack.isEmpty()) {
            prevStack.pop();
        }
    }

    public void moveLeft() {
        if (!prevStack.isEmpty()) {
            nextStack.push(prevStack.pop());
        }
    }

    public void moveRight() {
        if (!nextStack.isEmpty()) {
            insert(nextStack.pop());
        }
    }

    public int query(int k) {
        return max.get(k - 1);
    }
}
```

