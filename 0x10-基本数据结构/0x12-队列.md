# 1. 介绍

队列是一种“先进先出”的线性数据结构。一般来讲，元素从右端进入队列（入队)，从左端离开队列（出队)。于是我们称队列的左端为队头，右端为队尾。

元素进行多次入队、出队后，用于实现队列结构的数组的开头部分空间就会被严重浪费，所以我们经常将其优化为**“循环队列”**，也就是把队列看作一个首尾相接的环，只要队列中的元素个数在任意时刻都不超过环长，那么随着入队和出队操作的进行，存储元素的那一段位置就像沿着环不停地移动，重复利用着历史上曾被占用过的空间。C++ STL 中的 queue 就是一个循环队列，也是我们在代码中最常见的队列实现方式。

## 1.1 习题 45：Team Queue[^1]

有 $n$ 个小组要排成一个队列，每个小组中有若干人。

当一个人来到队列时，如果队列中已经有了自己小组的成员，他就直接插队排在自己小组成员的后面，否则就站在队伍的最后面。

请你编写一个程序，模拟这种小组队列。

- **输入格式**：

1. 输入将包含一个或多个测试用例。对于每个测试用例，第一行输入小组数量 $t$。

2. 接下来 $t$ 行，每行输入一个小组描述，第一个数表示这个小组的人数，接下来的数表示这个小组的人的编号。编号是 0 到 999999 范围内的整数。

3. 一个小组最多可包含 1000 个人。

4. 最后，命令列表如下。 有三种不同的命令：
   1. `ENQUEUE x` - 将编号是 $x$ 的人插入队列；
   2. `DEQUEUE` - 让整个队列的第一个人出队；
   3. `STOP` - 测试用例结束

5. 每个命令占一行。当输入用例 $t=0$ 时，代表停止输入。
6. 需注意：测试用例最多可包含 200000（20 万）个命令，因此小组队列的实现应该是高效的：入队和出队都需要使用常数时间。

- **输出样例**：

1. 对于每个测试用例，首先输出一行 `Scenario #k`，其中 $k$ 是测试用例的编号。

2. 然后，对于每个 `DEQUEUE` 命令，输出出队的人的编号，每个编号占一行。

3. 在每个测试用例（包括最后一个测试用例）输出完成后，输出一个空行。

- **数据范围**：

1. $1≤t≤1000$

- **输入样例**：

```
2
3 101 102 103
3 201 202 203
ENQUEUE 101
ENQUEUE 201
ENQUEUE 102
ENQUEUE 202
ENQUEUE 103
ENQUEUE 203
DEQUEUE
DEQUEUE
DEQUEUE
DEQUEUE
DEQUEUE
DEQUEUE
STOP
2
5 259001 259002 259003 259004 259005
6 260001 260002 260003 260004 260005 260006
ENQUEUE 259001
ENQUEUE 260001
ENQUEUE 259002
ENQUEUE 259003
ENQUEUE 259004
ENQUEUE 259005
DEQUEUE
DEQUEUE
ENQUEUE 260002
ENQUEUE 260003
DEQUEUE
DEQUEUE
DEQUEUE
DEQUEUE
STOP
0
```

- **输出样例**：

```
Scenario #1
101
102
103
201
202
203

Scenario #2
259001
259002
259003
259004
259005
260001

```

## 1.2 习题 46：蚯蚓[^2]

蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。

蛐蛐国里现在共有 $n$ 只蚯蚓，第 $i$ 只蚯蚓的长度为 $a_i$，所有蚯蚓的长度都是非负整数，即可能存在长度为 0 的蚯蚓。

每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只，将其切成两段。若有多只最长的，则任选一只。

神刀手切开蚯蚓的位置由有理数 $p$ 决定。一只长度为 $x$ 的蚯蚓会被切成两只长度分别为 $⌊px⌋$ 和 $x−⌊px⌋$ 的蚯蚓。特殊地，如果这两个数的其中一个等于 0，则这个长度为 0 的蚯蚓也会被保留。

此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加一个非负整数 $q$。

蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 $m$ 秒才能到来。

蛐蛐国王希望知道这 $m$ 秒内的战况。具体来说，他希望知道：

1. $m$ 秒内，每一秒被切断的蚯蚓被切断前的长度，共有 $m$ 个数。
2. $m$ 秒后，所有蚯蚓的长度，共有 $n+m$ 个数。

- **输入格式**：

1. 第一行包含六个整数 $n,m,q,u,v,t$，其中：$n,m,q$ 的意义参考题目描述；$u,v,t$ 均为正整数；你需要自己计算 $p=u/v$（保证 $0<u<v$）；$t$ 是输出参数，其含义将会在输出格式中解释。
2. 第二行包含 $n$ 个非负整数，为 $a_1,a_2,…,a_n$，即初始时 $n$ 只蚯蚓的长度。
3. 同一行中相邻的两个数之间，恰好用一个空格隔开。

- **输出格式**：

1. 第一行输出 $⌊m/t⌋$ 个整数，按时间顺序，依次输出第 $t$ 秒，第 $2t$ 秒，第 $3t$ 秒，……被切断蚯蚓（在被切断前）的长度。

2. 第二行输出 $⌊(n+m)/t⌋$ 个整数，输出 $m$ 秒后蚯蚓的长度；需要按从大到小的顺序，依次输出排名第 $t$，第 $2t$，第 $3t$，……的长度。

3. 同一行中相邻的两个数之间，恰好用一个空格隔开。
4. 即使某一行没有任何数需要输出，你也应输出一个空行。
5. 请阅读样例来更好地理解这个格式。

- **数据范围**：

1. $1≤n≤10^5$,
2. $0≤ai≤10^8$,
3. $0<p<1$,
4. $0≤q≤200$,
5. $0≤m≤7∗10^6$,
6. $0<u<v≤10^9$,
7. $1≤t≤71$

- **输入样例**：

```
3 7 1 1 3 1
3 3 2
```

- **输出样例**：

```
3 4 4 4 5 5 6
6 6 6 5 5 4 4 3 2 2
```

- **样例解释**：

1. 样例中，在神刀手到来前：3 只蚯蚓的长度为 3,3,2。

2. 1 秒后：一只长度为 3 的蚯蚓被切成了两只长度分别为 1 和 2 的蚯蚓，其余蚯蚓的长度增加了 1。最终 4 只蚯蚓的长度分别为 (1,2),4,3。 括号表示这个位置刚刚有一只蚯蚓被切断。
3. 2 秒后：一只长度为 4 的蚯蚓被切成了 1 和 3。5 只蚯蚓的长度分别为：2,3,(1,3),4。
4. 3 秒后：一只长度为 4 的蚯蚓被切断。6 只蚯蚓的长度分别为：3,4,2,4,(1,3)。
5. 4 秒后：一只长度为 4 的蚯蚓被切断。7 只蚯蚓的长度分别为：4,(1,3),3,5,2,4。
6. 5 秒后：一只长度为 5 的蚯蚓被切断。8 只蚯蚓的长度分别为：5,2,4,4,(1,4),3,5。
7. 6 秒后：一只长度为 5 的蚯蚓被切断。9 只蚯蚓的长度分别为：(1,4),3,5,5,2,5,4,6。
8. 7 秒后：一只长度为 6 的蚯蚓被切断。10 只蚯蚓的长度分别为：2,5,4,6,6,3,6,5,(2,4)。
9. 所以，7 秒内被切断的蚯蚓的长度依次为 3,4,4,4,5,5,6。
10. 7 秒后，所有蚯蚓长度从大到小排序为 6,6,6,5,5,4,4,3,2,2。

# 题解

## 习题 45：Team Queue

```java
public static abstract class AbstractQueue {

    protected Map<Integer, Integer> no2team;
    protected int[] teamSize;

    public AbstractQueue(Map<Integer, Integer> no2team, int[] teamSize) {
        this.no2team = no2team;
        this.teamSize = teamSize;
    }

    public abstract void enqueue(int no);

    public abstract int dequeue();
}

public void execute(BiFunction<Map<Integer, Integer>, int[], AbstractQueue> factory) {
    Scanner in = new Scanner(System.in);
    int caseNo = 1;
    for (;; caseNo++) {
        int t = in.nextInt();
        if (t == 0) {
            break;
        }

        Map<Integer, Integer> no2team = new HashMap<>();
        int[] teamSize = new int[t];
        for (int i = 0; i < t; i++) {
            int cnt = in.nextInt();
            teamSize[i] = cnt;
            for (int j = 0; j < cnt; j++) {
                no2team.put(in.nextInt(), i);
            }
        }
        AbstractQueue queue = factory.apply(no2team, teamSize);

        System.out.println("Scenario #" + caseNo);
        // 跳过换行符
        in.nextLine();
        for (String line = in.nextLine(); !line.equals("STOP"); line = in.nextLine()) {
            if (line.startsWith("ENQUEUE")) {
                queue.enqueue(Integer.parseInt(line.split(" ")[1]));
            } else {
                System.out.println(queue.dequeue());
            }
        }
        System.out.println();
    }
}

public static class Queue extends AbstractQueue {

    private final Deque<Integer>[] team2queue;
    private final Deque<Deque<Integer>> queue;

    public Queue(Map<Integer, Integer> team, int[] teamSize) {
        super(team, teamSize);
        team2queue = new Deque[teamSize.length];
        for (int i = 0; i < teamSize.length; i++) {
            team2queue[i] = new ArrayDeque<>(teamSize[i]);
        }
        queue = new ArrayDeque<>(teamSize.length);
    }

    @Override
    public void enqueue(int no) {
        Deque<Integer> q = team2queue[no2team.get(no)];
        if (q.isEmpty()) {
            queue.add(q);
        }
        q.add(no);
    }

    @Override
    public int dequeue() {
        Deque<Integer> q = queue.element();
        int no = q.remove();
        if (q.isEmpty()) {
            queue.remove();
        }

        return no;
    }
}
```

## 习题 46：蚯蚓





[^1]: https://www.acwing.com/problem/content/134/
[^2]: https://www.acwing.com/problem/content/135/