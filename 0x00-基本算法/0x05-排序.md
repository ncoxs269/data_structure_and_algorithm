# 0. 前言

在程序设计中，通常会使用到以下这些排序算法，这里把它们分为三类：

1. 选择排序、插入排序、冒泡排序
2. 堆排序、归并排序、快速排序
3. 计数排序、基数排序、桶排序

前两类是基于比较的排序算法，对 $n$ 个元素进行排序时，若元素比较大小的时间复杂度为 $O(1)$, 则第一类排序算法的时间复杂度为 $O(n^2)$，第二类排序算法的时间复杂度为 $O(n\log n)$。实际上，基于比较的排序算法的时间复杂度下界为 $O(n\log n)$，因此堆排序、归并排序与快速排序己经是时间复杂度最优的基于比较的排序算法。

第三类算法换了一种思路，它们不直接比较大小，而是对被排序的数值采取按位划分、分类映射等处理方式，其时间复杂度不仅与 $n$ 有关，还与数值的大小范围 $m$ 有关。

讨论这些排序算法的应用并以它们作为工具去解决问题才是我们的重点。

# 1. 离散化

排序算法的第一个应用是离散化。通俗地讲，“离散化”就是把无穷大集合中的若干个元素映射为有限集合以便于统计的方法。例如在很多情况下，问题的范围虽然定义在整数集合 $\Z$，但是只涉及其中 $m$ 个有限数值，并且与数值的绝对大小无关（只把这些数值作为代表，或只与它们的相对顺序有关）。此时，我们就可以把整数集合 $\Z$ 中的这 $m$ 个整数与 $1\sim m$ 建立映射关系。如果有一个时间、空间复杂度与数值范围 $\Z$
的大小有关的算法，在离散化后，该算法的时间、空间复杂度就降低为与 $m$ 相关。

具体地说，假设问题涉及 $\mathrm{int}$ 范围内的 $n$ 个整数 $a[1] \sim a[n]$，这 $n$ 个整数可能有重复，去重以后共有 $m$ 个整数。我们要把每个整数 $a[i]$ 用一个 $1\sim m$ 之间的整数代替，并且保持大小顺序不变，即如果 $a[i]$ 小于（或等于、大于）$a[j]$, 那么代替的整数也小于（或等于、大于）代替 $a[j]$ 的整数。

很简单，我们可以把 $a$ 数组排序并去掉重复的数值，得到有序数组 $b[1]\sim b[m]$, 在 $b$ 数组的下标 $i$ 与数值 $b[i]$ 之间建立映射关系。若要查询整数 $i(1 \le i \le m)$ 代替的数值，只需直接返回 $b[i]$；若要查询整数 $a[j](1 \le j \le n)$ 被哪个 $1\sim m$ 之间的整数代替，只需在数组 $b$ 中二分查找 $a[j]$ 的位置即可。

```java
void discrete() {  // 离散化
    sort(a + 1, a + n + 1);
    for (int i = 1; i <= n; i++)
        if (i == 1 || a[i] != a[i - 1])
            b[++m] = a[i];
}

int query(int x) {  // 查询 x 映射为哪个 1~m 之间的整数
    return lower_bound(b + 1, b + m + 1, x) - b;
}
```

## 1.1 习题18：Cinema

有 $m$ 部正在上映的电影，每部电影的语音和字幕都采用不同的语言，用一个 $\mathrm{int}$ 范围内的整数来表示语言。有 $n$ 个人相约一起去看其中一部电影，每个人只会一种语言，如果一个人能听懂电影的语音，他会很高兴；如果能看懂字幕，他会比较高兴；如果语音和字幕都不懂，他会不开心。请你选择一部电影让这 $n$ 个人一起看，使很高兴的人最多。若答案不唯一，则在此前提下再让比较高兴的人最多， $n,m \le 2 * 10^5$。