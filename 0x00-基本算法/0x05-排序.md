# 0. 前言

在程序设计中，通常会使用到以下这些排序算法，这里把它们分为三类：

1. 选择排序、插入排序、冒泡排序
2. 堆排序、归并排序、快速排序
3. 计数排序、基数排序、桶排序

前两类是基于比较的排序算法，对 $n$ 个元素进行排序时，若元素比较大小的时间复杂度为 $O(1)$, 则第一类排序算法的时间复杂度为 $O(n^2)$，第二类排序算法的时间复杂度为 $O(n\log n)$。实际上，基于比较的排序算法的时间复杂度下界为 $O(n\log n)$，因此堆排序、归并排序与快速排序己经是时间复杂度最优的基于比较的排序算法。

第三类算法换了一种思路，它们不直接比较大小，而是对被排序的数值采取按位划分、分类映射等处理方式，其时间复杂度不仅与 $n$ 有关，还与数值的大小范围 $m$ 有关。

讨论这些排序算法的应用并以它们作为工具去解决问题才是我们的重点。

## 0.1 拓展练习



# 1. 离散化

排序算法的第一个应用是离散化。通俗地讲，“离散化”就是把无穷大集合中的若干个元素映射为有限集合以便于统计的方法。例如在很多情况下，问题的范围虽然定义在整数集合 $\Z$，但是只涉及其中 $m$ 个有限数值，并且与数值的绝对大小无关（只把这些数值作为代表，或只与它们的相对顺序有关）。此时，我们就可以把整数集合 $\Z$ 中的这 $m$ 个整数与 $1\sim m$ 建立映射关系。如果有一个时间、空间复杂度与数值范围 $\Z$
的大小有关的算法，在离散化后，该算法的时间、空间复杂度就降低为与 $m$ 相关。

具体地说，假设问题涉及 $\mathrm{int}$ 范围内的 $n$ 个整数 $a[1] \sim a[n]$，这 $n$ 个整数可能有重复，去重以后共有 $m$ 个整数。我们要把每个整数 $a[i]$ 用一个 $1\sim m$ 之间的整数代替，并且保持大小顺序不变，即如果 $a[i]$ 小于（或等于、大于）$a[j]$, 那么代替的整数也小于（或等于、大于）代替 $a[j]$ 的整数。

很简单，我们可以把 $a$ 数组排序并去掉重复的数值，得到有序数组 $b[1]\sim b[m]$, 在 $b$ 数组的下标 $i$ 与数值 $b[i]$ 之间建立映射关系。若要查询整数 $i(1 \le i \le m)$ 代替的数值，只需直接返回 $b[i]$；若要查询整数 $a[j](1 \le j \le n)$ 被哪个 $1\sim m$ 之间的整数代替，只需在数组 $b$ 中二分查找 $a[j]$ 的位置即可。

```java
void discrete() {  // 离散化
    sort(a + 1, a + n + 1);
    for (int i = 1; i <= n; i++)
        if (i == 1 || a[i] != a[i - 1])
            b[++m] = a[i];
}

int query(int x) {  // 查询 x 映射为哪个 1~m 之间的整数
    return lower_bound(b + 1, b + m + 1, x) - b;
}
```

## 1.1 习题18：Cinema

有 $m$ 部正在上映的电影，每部电影的语音和字幕都采用不同的语言，用一个 $\mathrm{int}$ 范围内的整数来表示语言。有 $n$ 个人相约一起去看其中一部电影，每个人只会一种语言，如果一个人能听懂电影的语音，他会很高兴；如果能看懂字幕，他会比较高兴；如果语音和字幕都不懂，他会不开心。请你选择一部电影让这 $n$ 个人一起看，使很高兴的人最多。若答案不唯一，则在此前提下再让比较高兴的人最多， $n,m \le 2 * 10^5$。

# 题解

## 习题18：Cinema

### 书上的做法

虽然语言的范围在 $\mathrm{int}$ 以内，但是这 $m$ 部电影与 $n$ 个人最多涉及 $2 * m+n$ 种语言。我们把所有电影和人涉及的语言放进一个数组，排序并离散化，用一个 $1\sim 2*m +n$ 之间的整数代替每种语言。此时我们就可以用数组直接统计会上述每种语言的人的数量，从而选择满足题目要求的电影。时间复杂度为 $O((n+m)log(n+m))$。

### 我的做法

```java
public int chooseCinema(int[] a, int[] b, int[] c) {
    /*
     计算每种语言的人数，从最多人数语言开始，看看有没有这种语音的电影
     每种语言人的数量可能相同，一种语音的所有电影中可能包含多种字幕

     选择一门语言后，首先看看这门语言对应的语言电影，然后看看这门电影对应的字幕有多少人懂
     如果最大人数语言（要有对应的电影）不唯一，那每门语言都需要看看

     如果没有对应的语言电影，就只比较字幕了

     如果语言、字幕都没有对应的电影，就选最后一部


     要能够选择最多数量人的语言，还要支持按语言查找人数
     查找这个语言对应语音的电影，以及它们的字幕；查找语言对应字幕的电影
     */

    // 将人按语言分类并排序
    Map<Integer, Integer> lan2cnt = new HashMap<>(a.length / 2 + 1);
    for (int l : a) {
        lan2cnt.merge(l, 1, Integer::sum);
    }
    Lan[] lans = new Lan[lan2cnt.size()];
    int i = 0;
    for (Map.Entry<Integer, Integer> entry : lan2cnt.entrySet()) {
        lans[i++] = new Lan(entry.getKey(), entry.getValue());
    }
    Arrays.sort(lans);

    // 记录每种语言对应语音的电影，以及字幕语言对应的电影
    Map<Integer, List<Integer>> yy2movies = new HashMap<>(b.length / 2 + 1);
    Map<Integer, List<Integer>> zm2movies = new HashMap<>(b.length / 2 + 1);
    for (i = 0; i < b.length; i++) {
        yy2movies.computeIfAbsent(b[i], k -> new ArrayList<>()).add(i + 1);
        zm2movies.computeIfAbsent(c[i], k -> new ArrayList<>()).add(i + 1);
    }

    int ans = 0;
    for (int l = lans.length - 1, r = lans.length; r > 0; r = l, l--) {
        while (l > 0 && lans[l - 1].cnt == lans[l].cnt) {
            l--;
        }
        // [l,r) 之间是人数相同的语言
        int maxZm = -1;
        for (int j = l; j < r; j++) {
            // 选择对应语言语音的电影
            for (int movie : yy2movies.getOrDefault(lans[j].lan, Collections.emptyList())) {
                // 查找电影字幕对应的人数
                int zmrs = lan2cnt.getOrDefault(c[movie - 1], 0);
                // 选择较高兴最多人数的电影
                if (zmrs > maxZm) {
                    maxZm = zmrs;
                    ans = movie;
                }
            }
        }
        if (maxZm != -1) {
            break;
        }
    }
    // 没有对应语言的电影
    if (ans == 0) {
        for (int l = lans.length - 1, r = lans.length; r > 0; r = l, l--) {
            while (l > 0 && lans[l - 1].cnt == lans[l].cnt) {
                l--;
            }
            // [l,r) 之间是人数相同的语言
            for (int j = l; j < r; j++) {
                // 选择对应语言字幕的电影
                for (int movie : zm2movies.getOrDefault(lans[j].lan, Collections.emptyList())) {
                    ans = movie;
                }
            }
            if (ans != 0) {
                break;
            }
        }
    }

    // 语音、字幕都不满足，就选最后的电影
    return ans != 0 ? ans : b.length;
}

static class Lan implements Comparable<Lan> {
    int lan;
    int cnt;

    public Lan(int lan, int cnt) {
        this.lan = lan;
        this.cnt = cnt;
    }


    @Override
    public int compareTo(Lan o) {
        return Integer.compare(cnt, o.cnt);
    }

    @Override
    public String toString() {
        return "(" + lan + "," + cnt + ")";
    }
}
```

