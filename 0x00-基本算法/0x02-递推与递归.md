# 1. 递推与递归的宏观描述 

一个实际问题的各种可能情况构成集合的通常称为“状态空间”，而程序的运行则是对于状态空间的遍历，算法和数据结构则通过划分、归纳、提取、抽象来帮助提高程序遍历状态空间的效率。递推和递归就是程序遍历状态空间的两种基本方式。

对于一个待求解的问题，当它局限在某处边界、某个小范围或者某特殊种情形下时，其答案往往是已知的。如果能够将该解答的应用场景扩大到原问题状态的空间,并且扩展过程的每个步骤具有相似性，就可以考虑使用递推或者递归求解。

以已知的“问题边界”为起点向“原问题”正向推导的扩展方式就是递推。然而在很多时候,推导的路线难以确定,这时以“原问题”为起点尝试寻找状态把空间缩小到己知的“问题边界”的路线,再通过该路线反向回溯遍历的方式就是递归。我们通过下页两幅图表示来递推与递归的差别。

![image-20220408155602428](0x02-递推与递归.assets/image-20220408155602428-16494045642361.png)

我们刚才也提到，使用递推或递归要“求原问题”与“问题边界”之间的每个变换步骤具有相似性,这样我们才能够设计一段程序实现这个步骤,将其重复作用于问题之中。换句话说,程序在每个步骤上应该面对相同种类的问题,这些问题都是原问题的一个子问题,可能仅在规模或者某些限制条件上有所区别,并且能够使用“求解原问题的程序”进行求解。

对于递归算法,有了上面这个前提,我们就可以让程序在每个变换步骤中执行三个操作:

1. 缩小问题状态空间的规模。这意味着程序尝试寻找在“原问题”与“问题边界”之间的变换路线，并正在向探索的路线上迈出一步。
2. 尝试求解规模缩小以后的问题，结果可能是成功，也可能是失败。
3. 如果成功，即找到了规模缩小后的问题的答案，那么答案将扩展到当前问题。如果失败，那么重新回到当前问题,程序可能继续会寻找当前问题的其他变换路线,直至最终确定当前问题无法求解。

在以上三个操作中有两点颇为关键。

1. 一是“如何尝试求解规模缩小以后的问题”。因为规模缩小以后的问题是原问题的一个子问题,所以我们可以把它视为一个新的“原问题”由相同的程序(上述三个操作)进行求解，这就是所谓的“**自身调用自身**”。
2. 二是如果求解子问题失败,程序需要重新到回当前问题去寻找其他变换的路线,因此把当前问题缩小为子问题时所做的对当前问题状态产生影响的事情应该全部失效，这就是所谓的“**回溯时还原现场**”。

上面这类程序就是“递归”的遍历方式，其整体流程如下页图所示。

![image-20220408160346412](0x02-递推与递归.assets/image-20220408160346412-16494050277782.png)

可以看到，递归程序的基本单元是由“缩小”“求解”“扩展”组成的一种变换步骤,只是在“求解”时因为问题的相似性,不断重复使用了这样一种变换步骤,直至在已知问题的边界上直接确定答案。对于其中任意一条从“原问题”到“问题边界”的变换路线(图中实线圈出的路径)，横向来看，它的每一层是一次递归程序体的执行；纵向来看,它的左右两边分别是寻找路线和沿其推导的流程。为了保证每层的“缩小”与“扩展”能够衔接在同一形式的问题上，“求解”操作自然要保证在执行前后程序面对问题的状态是相同的，这也就是“还原现场”的必要性所在。

# 2. 递推与递归的简单应用

在使用枚举算法蛮力探索问题的整个“状态空间”时，经常需要递归。按照规模大小，有如下几种常见的枚举形式和遍历方式:

![image-20220408160930389](0x02-递推与递归.assets/image-20220408160930389-16494053716523.png)

“多项式”型的枚举在程序设计中随处可见。上一节中最短Hamilton路径问题的朴素做法，是一种“排列”型的枚举。本节下面的例题“费解的开关”中的枚举则是一种“指数”型的枚举。

## 2.1 习题5：递归实现指数型枚举

从 `1~n` 这 `n(n<20)` 个整数中随机选取任意多个，输出所有可能的选择方案。

## 2.2 习题6：递归实现组合型枚举

从 `1~n` 这 `n` 个整数中随机选出 `m(0<=m<=n<20)` 个，输出所有可能的选择方案。

## 2.3 习题7：递归实现排列型枚举

从 `1~n` 这 `n(n<10)` 个整数排成一行后随机打乱顺序，输出所有可能的次序。

## 2.4 习题8：费解的开关

在一5*5个的01矩阵中，点击任意一个位置，该位置以及它上、下、左、右四个相邻的位置中的数字都会变化(0变成1，1变成0)，问:最需要少多少次点击可以把一个给定的01矩阵变成全0矩阵?

# 题解

## 习题5：递归实现指数型枚举

这等价于每个整数可以选可以不选，所有可能方案的总数共有 $2^n$ 种。通过前两节的学习,我们已经知道可以进行一次循环,利用位运算来列举所有的选择方案。这一次我们使用递归来求解，在每次递归中分别尝试某个数“选”或“不选”两条分支，将尚未确定的整数数量减少1，从而转化为一个规模更小同类的问题。

```java
public List<List<Integer>> combination(int n) {
    ans = new ArrayList<>();
    path = new ArrayList<>();
    dfs(n, 1);

    return ans;
}

private List<List<Integer>> ans;
private ArrayList<Integer> path;

private void dfs(int n, int i) {
    if (i > n) {
        ans.add((List<Integer>) path.clone());
        return;
    }
    // 不选
    dfs(n, i + 1);
    // 选
    path.add(i);
    dfs(n, i + 1);
    path.remove(path.size() - 1);
}
```

## 习题6：递归实现组合型枚举

```java
public List<List<Integer>> combination(int n, int m) {
    this.n = n;
    this.m = m;
    ans = new ArrayList<>();
    path = new ArrayList<>(m);
    dfs(1);

    return ans;
}

private int n, m;
private List<List<Integer>> ans;
private ArrayList<Integer> path;

private void dfs(int i) {
    if (path.size() == m) {
        ans.add((List<Integer>) path.clone());
        return;
    }
    // 先添加
    path.add(i);
    dfs(i + 1);
    path.remove(path.size() - 1);
    // 后面数字足够的情况下不添加
    if (n - i >= m - path.size()) {
        dfs(i + 1);
    }
}
```

上面的程序和指数型枚举比起来增加了一个剪枝操作。寻找变换路线其实就是“搜索”的过程,如果能够及时确定当前问题一定是无解的，就不需要到达问题边界才返回结果。这条剪枝保证我们不会进入无解的分支,所以时间复杂度就从 $2^n$ 降低为 $C^m_n$。关于搜索及其剪枝，我们将从第0x20节开始用一章的篇幅详细讲解。

## 习题7：递归实现排列型枚举

### 方法1

该问题也被称为全排列问题，所有可能方案的总数有 `n!` 种。在这里，递归需要求解问题的是“把指定的 `n` 个整数按照任意次序排列”，在每次递归中,我们尝试把每个可用的数作为数列中的下一个数，求解“把剩余 `n-1` 个整数按照任意次序排列”这个规模更小的子问题。

```java
public List<List<Integer>> enumeration(int n) {
    this.n = n;
    ans = new ArrayList<>();
    visited = new boolean[n + 1];
    order = new int[n + 1];
    dfs(1);

    return ans;
}

private int n;
private List<List<Integer>> ans;
private boolean[] visited;
private int[] order;

private void dfs(int i) {
    if (i > n) {
        List<Integer> path = new ArrayList<>(n);
        for (int j = 1; j <= n; j++) {
            path.add(order[j]);
        }
        ans.add(path);
        return;
    }
    for (int j = 1; j <= n; j++) {
        if (visited[j]) {
            continue;
        }
        visited[j] = true;
        order[i] = j;
        dfs2(i + 1);
        visited[j] = false;
    }
}
```

### 方法2

通过交换和移位，避免每次需要 `n` 次遍历。

```java
public List<List<Integer>> enumeration(int n) {
    ans = new ArrayList<>();
    for (int i = 1; i <= n; i++) {
        path[i] = i;
    }
    dfs(1);

    return ans;
}

private List<List<Integer>> ans;
private int[] path = new int[10];

private void dfs(int i) {
    if (i >= n) {
        List<Integer> order = new ArrayList<>(n);
        for (int j = 1; j <= n; j++) {
            order.add(path[j]);
        }
        ans.add(order);
        return;
    }

    for (int j = i; j <= n; j++) {
        set(i, j);
        dfs(i + 1);
        unset(i, j);
    }
}

/**
  * 将 path[j] 放到 i 处，path[i] 放到 i+1 处，(i,j) 中的元素后移一位
  */
private void set(int i, int j) {
    if (i == j) {
        return;
    }
    int elemI = path[i];
    path[i] = path[j];
    System.arraycopy(path, i + 1, path, i + 2, j - i - 1);
    path[i + 1] = elemI;
}

/**
 * 执行和 set 相反的操作
 */
private void unset(int i, int j) {
    if (i == j) {
        return;
    }
    int elemJ = path[i];
    path[i] = path[i + 1];
    System.arraycopy(path, i + 2, path, i + 1, j - i - 1);
    path[j] = elemJ;
}
```

## 习题8：费解的开关

