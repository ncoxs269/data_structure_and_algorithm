# 0. 介绍

倍增，字面意思就是“成倍增长”。这是指我们在进行递推时，如果状态空间很大，通常的线性递推无法满足时间与空间复杂度的要求，那么我们可以通过成倍增长的方式，只递推状态空间中在 2 的整数次幂位置上的值作为代表。当需要其他位置上的值时，我们通过“任意整数可以表示成若干个 2 的次幂项的和”这一性质，使用之前求出的代表值拼成所需的值。所以使用倍增算法也要求我们递推的问题的状态空间关于 2 的次幂具有可划分性。

“倍增”与“二进制划分”两个思想互相结合，降低了求解很多问题的时间与空间复杂度。我们之前学习的快速幂其实就是“倍增”与“二进制划分”思想的一种体现。在本节中，我们研究序列上的倍增问题，包括求解 RMQ (区间最值）问题的 ST 算法。关于求解最近公共祖先（LCA) 等在树上的倍增应用，我们将在 0x63 节中进行探讨。

试想一个这样的问题：

> 给定一个长度为 $N$ 的数列然后进行若干次询问，每次给定一个整数 $T$, 求出最大的 $k$, 满足 $\sum_{i=1}^{k}A[i] \le T$。你的算法必须是在线的（必须即时回答每一个询问，不能等待收到所有询问后再统一处理），假设 $0 \le T \le \sum_{i=1}^{N}A[i]$。

最朴素的做法当然是从前向后枚举 $k$, 每次询问花费的时间与答案的大小有关，最坏情况下为 $\mathrm{O}(N)$。

如果我们能够先花费 $\mathrm{O}(N)$ 的时间预处理 $A$ 数组的前缀和数组 $S$ 就可以二分 $k$ 的位置，比较 $S[k]$ 与 $T$ 的大小来确定二分上下界的变化，每次询问花费的时间都是 $\mathrm{O}(\log N)$。这个算法在平均情况下表现很好，但是它的缺点是如果每次询问给定的整数 $T$ 都非常小，造成答案 $k$ 也非常小，那么该算法可能还不如从前向后枚举更优。

我们可以设计这样一种倍增算法：

1. 令 $p =1,k = 0, sum = 0$。
2. 比较“$A$ 数组中 $k$ 之后的 $p$ 个数的和”与 $T$ 的关系，也就是说，如果 $sum +S[k + p] - S[k] \le T$, 则令 $sum += S[k + p] -S[k] , k += p, p *= 2$, 即累加上这 $p$ 个数的和，然后把 $p$ 的跨度增长一倍。如果 $sum + S[k + p] -S[k ] > T$, 则令 $p/= 2$。
3. 重复上一步，直到 $p$ 的值变为 0, 此时 $k$ 就是答案。

这个算法始终在答案大小的范围内实施“倍增”与“二进制划分”思想，通过若干长度为 2 的次幂的区间拼成最后的 $k$, 时间复杂度级别为答案的对数，能够应对 $T$ 的各种大小情况。

## 0.1 习题24：Genius ACM

给定一个整数 $M$, 对于任意一个整数集合定义“校验值”如下：

从集合 $S$ 中取出 $M$ 对数（即 $2*M$ 个数，不能重复使用集合中的数，如果 $S$ 中的整数不够 $M$ 对，则取到不能取为止），使得“每对数的差的平方”之和最大，这个最大值就称为集合 $S$ 的“校验值”。

现在给定一个长度为 $N$ 的数列 $A$ 以及一个整数 $T$。我们要把 $A$ 分成若干段，使得每一段的“校验值”都不超过 $T$。求最少需要分成几段。