# 0. 介绍

贪心是一种在每次决策时采取当前意义下最优策略的算法，因此，**使用贪心法要求问题的整体最优性可以由局部最优性导出**。贪心算法的正确性需要证明，常见的证明手段有

1. 微扰（邻项交换）：证明在任意局面下，任何对局部最优策略的微小改变都会造成整体结果变差。经常
   用于以“排序”为贪心策略的证明。
2. 范围缩放：证明任何对局部最优策略作用范围的扩展都不会造成整体结果变差。
3. 决策包容性：证明在任意局面下，作出局部最优决策以后，在问题状态空间中的可达集合包含了作出其他任何决策后的可达集合。换言之，这个局部最优策略提供的可能性包含其他所有策略提供的可能性。
4. 反证法
5. 数学归纳法

我们通过几道例题来介绍贪心算法的应用。

## 0.1 习题25：Sunscreen

有 $C$ 头奶牛日光浴，第 $i$ 头奶牛需要 $\mathrm{minSPF}[i]$ 和 $\mathrm{maxSPF}[i]$ 单位强度之间的阳光。每头奶牛在日光浴前必须涂防晒霜，防晒霜有 $L$ 种，涂上第 $i$ 种之后，身体接收到的阳光强度就会稳定为 $\mathrm{SPF}[i]$，第 $i$ 种防晒霜有 $\mathrm{cover}[i]$ 瓶。求最多可以满足多少头奶牛进行日光浴。$C,L \le 2500$。

## 0.2 习题26：Stall Reservations

有 $N$ 头牛在畜栏中吃草。每个畜栏在同一时间段只能提供给一头牛吃草，所以可能会需要多个畜栏。给定 $N$ 头牛和每头牛开始吃草和结束吃草的时间，每头牛在给定时间段内会一直吃草，求需要的最小畜栏数目和每头牛对应的畜栏方案。$N \le 5*10^4$。

## 0.3 习题27：Radar Installation

校长想通过监控设备覆盖学校内的 $N$ 座建筑物，每座建筑物被视作一个质点，在笛卡尔坐标系中给出它们的坐标 $(x,y)$, 并且所有建筑物均处在 $x$ 轴的上方。因为学校的供电和传输线路均沿 $x$ 轴，所以监控设备只被允许建立在 $x$ 轴上。每台监控设备的监控范围均为一个半径为的圆形，圆心即为这台设备。现给出 $N$ 座建筑物的坐标，问：最少需要几台这样的设备可以实现对所有建筑物的监控？$N \le 1000$。

# 题解

## 习题25：Sunscreen

按照 $\mathrm{minSPF}$ 递减的顺序把奶牛排序，依次考虑每头奶牛。遍历的时候考虑每头奶牛在能用的防晒霜里面，应该用哪个。

对于每头奶牛，扫描一遍所有的防晒霜，在这头奶牛能用（能用指时是该防晒霜的强度符合这头奶牛的范围，并且瓶数还有剩余）的防晒霜里找 $\mathrm{SPF}$ 值最大的使用。

以上算法的贪心策略是在满足条件的前提下每次选 $\mathrm{SPF}$ 最大的防晒霜。这个策略为什么是正确的呢？我们考虑这一步策略的作用范围扩展到后续其他奶牛之后产生的影响。每瓶防晒霜是否可用，会被 $\mathrm{minSPF}$ 与 $\mathrm{maxSPF}$ 两个条件限制**。因为奶牛已被按照 $\mathrm{minSPF}$ 递减排序，所以每一个不低于当前奶牛 $\mathrm{minSPF}$ 值的防晒霜，都不会低于后面其他奶牛的 $\mathrm{minSPF}$**。也就是说，对于当前奶牛可用的任意两瓶防晒霜 $x$ 与 $y$, 如果 $\mathrm{SPF}[x] < \mathrm{SPF}[y],$ 那么后面其他奶牛只可能出现 “$x,y$ 都能用”、“$x,y$ 都不能用”或者“$x$ 能用, $y$ 不能用”这三种情况之一。因此当前奶牛选择 $\mathrm{maxSPF}$ 较大的 $y$ 去使用，对于整体问题的影响显然比选择 $maxSPF$ 较小的 $x$ 更好。

假如奶牛已被按照 $\mathrm{maxSPF}$ 递增排序，那么没有上面的条件。对于当前奶牛可用的任意两瓶防晒霜 $x$ 与 $y$, 如果 $\mathrm{SPF}[x] < \mathrm{SPF}[y],$ 那么后面其他奶牛可能出现 “$x,y$ 都能用”、“$x,y$ 都不能用”、“$x$ 能用, $y$ 不能用”或者“$x$ 不能用, $y$ 能用”这四种情况，导致无法使用贪心。

另外，每头奶牛对答案的贡献至多是 1。即使让当前这头奶牛放弃日光浴，留下防晒霜给后面的某一头奶牛用，对答案的贡献也不会变得更大。综上所述，尽量满足当前的奶牛，并选择 $\mathrm{SPF}$ 值尽量大的防晒霜是一个正确的贪心策略。

**这个贪心算法具有范围缩放和决策包容性。在遍历的每次操作中，都能确定一个最优解**。

```java
public int sunscreen(int[][] cows, int[][] spfs) {
    Arrays.sort(cows, (a, b) -> -Integer.compare(a[0], b[0]));
    TreeMap<Integer, Integer> tree = new TreeMap<>();
    for (int[] spf : spfs) {
        // 注意可能有重复的防晒值
        tree.merge(spf[0], spf[1], Integer::sum);
    }

    int ans = 0;
    for (int[] cow : cows) {
        Integer floor = tree.floorKey(cow[1]);
        if (floor != null && floor >= cow[0]) {
            tree.merge(floor, -1, (old, delta) -> {
                if (old + delta == 0) {
                    return null;
                } else {
                    return old + delta;
                }
            });
            ans++;
        }
    }

    return ans;
}
```

## 习题26：Stall Reservations

所有有交集的牛，它们都需要在不同的围栏中。围栏可以复用，因此围栏最小数量=某一时刻牛的最多数量

### 1. 错误的思路

按结束时间升序排序。一个已经结束的牛不会再影响之后的牛。

每次检查 $begin[i]$ 和前面的 $cnt$ 个 $end[j](j<i)$ 有交集，围栏数需要是 $max(cnt)+1$。

这个做法的错误之处在于，它把最大交集数当成了某一时刻牛的最多数量。实际上有交集并不代表 $[i,j]$ 每时每刻都有冲突，某一时刻牛的最多数量=$[i,j]$ 在这一时刻都有冲突。

### 2. 书上的做法

按照开始吃草的时间把牛升序排序。按照开始时间遍历，能够在遍历到 $i$ 的时候查找当前时间还有哪些牛没结束。

维护一个数组 $S$, 记录当前每个畜栏安排进去的最后一头牛，最初没有畜栏。

依次对于每头牛，扫描数组 $S$，找到任意一个畜栏，满足当前的牛开始吃草的时间不早于畜栏中最后一头牛结束吃草的时间。如果这样的畜栏不存在，则为其新建一个畜栏。

这个贪心算法的时间复杂度是 $\mathrm{O}(N^2)$。我们可以用一个小根堆维护每个畜栏最后一头牛结束吃草的时间，尝试把当前的牛安排在堆顶（结束时间最早）的畜栏中，时间复杂度可以降低到 $\mathrm{O}(N\log N)$。

```java
public void arrange() {
    Scanner in = new Scanner(System.in);
    int n = in.nextInt();
    // cow 还需要记录记录下标
    int[][] cow = new int[n][3];
    for (int i = 0; i < n; i++) {
        cow[i][0] = in.nextInt();
        cow[i][1] = in.nextInt();
        cow[i][2] = i;
    }

    // 按照开始时间进行排序
    Arrays.sort(cow, Comparator.comparingInt((int[] a) -> a[0]));
    // a[] = {结束时间，所处的畜栏}
    PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt((int[] a) -> a[0]));
    // 最大围栏数量
    int stallCnt = 0;
    // stalls[i] = 第 i 头牛所处的围栏
    int[] stalls = new int[n];
    Queue<Integer> unusedStalls = new LinkedList<>();;
    for (int i = 0; i < n; i++) {
        // 将已经结束的牛弹出来，这样就有围栏空了出来
        while (!pq.isEmpty() && pq.peek()[0] < cow[i][0]) {
            unusedStalls.offer(pq.poll()[1]);
        }
        // 如果没有可用的围栏，就需要新建围栏
        int idx = cow[i][2];
        if (unusedStalls.isEmpty()) {
            stalls[idx] = ++stallCnt;
        } else {  // 否则复用围栏
            stalls[idx] = unusedStalls.poll();
        }
        pq.offer(new int[]{cow[i][1], stalls[idx]});
    }

    // 输出围栏数量
    System.out.println(stallCnt);
    // 输出每头牛所处的围栏
    for (int i = 0; i < n; i++) {
        System.out.println(stalls[i]);
    }
}
```

### 3. 双指针做法

如果不需要每头牛对应的畜栏方案，那么有另一种方法，参见 [LeetCode 253. 会议室 II](https://leetcode-cn.com/problems/meeting-rooms-ii/)。和上面的思路其实类似，只不过用排序数组代替了优先队列。

