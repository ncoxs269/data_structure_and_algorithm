# 0. 介绍

贪心是一种在每次决策时采取当前意义下最优策略的算法，因此，**使用贪心法要求问题的整体最优性可以由局部最优性导出**。贪心算法的正确性需要证明，常见的证明手段有

1. 微扰（邻项交换）：证明在任意局面下，任何对局部最优策略的微小改变都会造成整体结果变差。经常
   用于以“排序”为贪心策略的证明。
2. 范围缩放：证明任何对局部最优策略作用范围的扩展都不会造成整体结果变差。
3. 决策包容性：证明在任意局面下，作出局部最优决策以后，在问题状态空间中的可达集合包含了作出其他任何决策后的可达集合。换言之，这个局部最优策略提供的可能性包含其他所有策略提供的可能性。
4. 反证法
5. 数学归纳法

我们通过几道例题来介绍贪心算法的应用。

## 0.1 习题25：Sunscreen

有 $C$ 头奶牛日光浴，第 $i$ 头奶牛需要 $\mathrm{minSPF}[i]$ 和 $\mathrm{maxSPF}[i]$ 单位强度之间的阳光。每头奶牛在日光浴前必须涂防晒霜，防晒霜有 $L$ 种，涂上第 $i$ 种之后，身体接收到的阳光强度就会稳定为 $\mathrm{SPF}[i]$，第 $i$ 种防晒霜有 $\mathrm{cover}[i]$ 瓶。求最多可以满足多少头奶牛进行日光浴。$C,L \le 2500$。

# 题解

## 习题25：Sunscreen

按照 $\mathrm{minSPF}$ 递减的顺序把奶牛排序，依次考虑每头奶牛。

对于每头奶牛，扫描一遍所有的防晒霜，在这头奶牛能用（能用指时是该防晒霜的强度符合这头奶牛的范围，并且瓶数还有剩余）的防晒霜里找 $\mathrm{SPF}$ 值最大的使用。

以上算法的贪心策略是在满足条件的前提下每次选 $\mathrm{SPF}$ 最大的防晒霜。这个策略为什么是正确的呢？我们考虑这一步策略的作用范围扩展到后续其他奶牛之后产生的影响。每瓶防晒霜是否可用，会被 $\mathrm{minSPF}$ 与 $\mathrm{maxSPF}$ 两个条件限制**。因为奶牛已被按照 $\mathrm{minSPF}$ 递减排序，所以每一个不低于当前奶牛 $\mathrm{minSPF}$ 值的防晒霜，都不会低于后面其他奶牛的 $\mathrm{minSPF}$**。也就是说，对于当前奶牛可用的任意两瓶防晒霜 $x$ 与 $y$, 如果 $\mathrm{SPF}[x] < \mathrm{SPF}[y],$ 那么后面其他奶牛只可能出现 “$x,y$ 都能用”、“$x,y$ 都不能用”或者“$x$ 能用, $y$ 不能用”这三种情况之一。因此当前奶牛选择 $\mathrm{maxSPF}$ 较大的 $y$ 去使用，对于整体问题的影响显然比选择 $maxSPF$ 较小的 $x$ 更好。

假如奶牛已被按照 $\mathrm{maxSPF}$ 递减排序，那么没有上面的条件。对于当前奶牛可用的任意两瓶防晒霜 $x$ 与 $y$, 如果 $\mathrm{SPF}[x] < \mathrm{SPF}[y],$ 那么后面其他奶牛可能出现 “$x,y$ 都能用”、“$x,y$ 都不能用”、“$x$ 能用, $y$ 不能用”或者“$x$ 不能用, $y$ 能用”这四种情况，导致无法使用贪心。

另外，每头奶牛对答案的贡献至多是 1。即使让当前这头奶牛放弃日光浴，留下防晒霜给后面的某一头奶牛用，对答案的贡献也不会变得更大。综上所述，尽量满足当前的奶牛，并选择 $\mathrm{SPF}$ 值尽量大的防晒霜是一个正确的贪心策略。

```java
public int sunscreen(int[][] cows, int[][] spfs) {
    Arrays.sort(cows, (a, b) -> -Integer.compare(a[0], b[0]));
    TreeMap<Integer, Integer> tree = new TreeMap<>();
    for (int[] spf : spfs) {
        // 注意可能有重复的防晒值
        tree.merge(spf[0], spf[1], Integer::sum);
    }

    int ans = 0;
    for (int[] cow : cows) {
        Integer floor = tree.floorKey(cow[1]);
        if (floor != null && floor >= cow[0]) {
            tree.merge(floor, -1, (old, delta) -> {
                if (old + delta == 0) {
                    return null;
                } else {
                    return old + delta;
                }
            });
            ans++;
        }
    }

    return ans;
}
```

